# "Кратко"

# Каждое значение в Python имеет тип. Поскольку всё в Python — объекты, типы являются классами, а значения — экземплярами (объектами) этих классов.


# "Числа"

# Целые числа, числа с плавающей запятой и комплексные числа относятся к группе чисел.
# В Python они представлены классами int, float и complex.

# Мы можем использовать функцию type(), чтобы узнать класс переменной или значения,
# и функцию isinstance() для проверки принадлежности объекта определённому классу:
print('ЧИСЛА --------------------------------------------------------')
a: int = 5
print(a, "is of type", type(a))
# 5 is of type <class 'int'>
b: float = 2.0
print(b, "is of type", type(b))
# 2.0 is of type <class 'float'>
c: complex = 1+2j
print(c, "is complex number?", isinstance(1+2j, complex))
# (1+2j) is complex number? True
d = 25
print('d =', d, 'of type ', type(d))
print('--------------------------------------------------------------')

# Целые числа могут быть любой длины, они ограничиваются лишь доступной памятью в 4 байта.

# Числа с плавающей запятой имеют ограниченную точность.
# Визуально разницу между целым числом и числом с плавающей запятой можно заметить в консоли по наличию точки:
# 1 — целое число, 1.0 — с плавающей запятой

# Комплексные числа записываются в форме x+yj, где x — действительная часть числа, а y — мнимая.


# "Списки"

# Список представляет собой упорядоченную последовательность элементов.
# Он очень гибкий и является одним из самых используемых типов в Python.
# Элементы списка необязательно должны быть одного типа.

# Объявить список довольно просто. Внутрь квадратных скобок помещаются элементы списка, разделённые запятой:
a: list = [1, 2.2, 'python']

# Мы можем использовать оператор [] для извлечения элемента (такая операция называется «доступ по индексу»)
# или диапазона элементов (такая операция называется «извлечение среза») из списка.
# В Python индексация начинается с нуля:
print('СПИСКИ -------------------------------------------------------')
a: list = [5, 10, 15, 20, 25, 30, 35, 40]
print('a:', a)
print("a[2] =", a[2])
# a[2] = 15
print("a[0:3] =", a[0:3])  # slices
# a[0:3] = [5, 10, 15]
print("a[5:] =", a[5:])
# a[5:] = [30, 35, 40]

# Списки являются изменяемым типом, т.е. значения его элементов можно изменить:
a: list = [1, 2, 3]
print('a:', a)
print('a[2] = 4')
a[2] = 4
print('значение a[2] заменено на 4:', a)
# [1, 2, 4]
print(type(a))
print('--------------------------------------------------------------')


# "Кортежи"

# Так же как и список, кортеж (tuple) является упорядоченной последовательностью элементов.
# Вся разница заключается в том, что кортежи неизменяемы.

# Кортежи используются для защиты данных от перезаписи и обычно работают быстрее, чем списки, т.к. их нельзя изменять.

# Для создания кортежа нужно поместить внутрь круглых скобок элементы, разделённые запятой:
t: tuple = (5, 'program', 1+3j)
# Мы можем использовать оператор извлечения среза []
# для извлечения элементов, но мы не можем менять их значения:
print('КОРТЕЖИ ------------------------------------------------------')
print("t[1] =", t[1])
# t[1] = program
print("t[0:5] =", t[0:5])
print("t[1:2] =", t[1:2])
print("t[1:3] =", t[1:3], type(t[1]), type(t[2]))
print(type(t))
print('--------------------------------------------------------------')


# "Строки"

# Строка представляет собой последовательность символов.
# Мы можем использовать одинарные или двойные кавычки для создания строки.
# Многострочные строки можно обозначить тройными кавычками, ''' или """:
s1: str = "Простая строка"
s2: str = '''
Многострочная строка
    1
    2
    3
    ... e.g ...'''
print('СТРОКИ -------------------------------------------------------')
print(s1, s2)
print(s2[26])
print(s2[32])
print(s2[38])
print(s2[44:])
print(type(s2))
print('--------------------------------------------------------------')
# Как и в случае со списками и кортежами, мы можем использовать оператор [] и со строками.
# Стоит отметить, что строки в Python относятся к категории неизменяемых последовательностей,
# то есть все функции и методы могут лишь создавать новую строку.


# "Множества"

# Множество является неупорядоченной уникализированной последовательностью.
# Объявляется множество с помощью элементов, разделённых запятой, внутри фигурных скобок:
a: set = {5, 2, 3, 1, 4}
# вывод переменной множества
print('МНОЖЕСТВА ----------------------------------------------------')
print("a =", a)
# a = {1, 2, 3, 4, 5}

# Над множествами можно выполнять такие операции, как объединение и пересечение.
# Т.к. элементы в множестве должны быть уникальны, они автоматически удаляют дубликаты:
a: set = {1, 2, 2, 3, 3, 3}
print("a =", a)
# a = {1, 2, 3}
b = {7, 4, 9, 3, 4, 6, 7, 8, 9, 1, 2, 3, 2, 5, 6, 7, 8, 9}
print("b =", b, "-->", type(b))
# Поскольку множество является неупорядоченной последовательностью, оператор извлечения среза здесь не работает:
try:
    a: set = {1, 2, 3}
    print(a[1])
except:
    print("TypeError: 'set' object is not subscriptable")
# Traceback (most recent call last):
#   File "/Users/dmitrijvaledinskij/Python/Python YLAB/data_types.py", line 144, in <module>
#     print(a[1])
# TypeError: 'set' object is not subscriptable
print(type(a))
print('--------------------------------------------------------------')



# "Словари"

# Словари — неупорядоченные наборы пар ключ-значение.

# Они используются, когда нужно сопоставить каждому из ключей значение и иметь возможность быстро получать 
# доступ к значению, зная ключ. В других языках словари обычно называются map, hash или object. 
# Словари оптимизированы для извлечения данных. Чтобы извлечь значение, нужно знать ключ.

# Словарь объявляется парами элементов в форме ключ:значение, заключенными в фигурные скобки:
d: dict = {1:'value', 'key':2}
print('СЛОВАРИ -----------------------------------------------------')
print("dictionary d:", d)
print(type(d))
# <class 'dict'>

# Значение может быть любого типа, а вот ключ — только неизменяемого.

# Мы используем ключ, чтобы получить соответствующее ему значение. Но не наоборот:
d: dict = {1:'value', 'key':2}
print("d[1] =", d[1])
# d[1] = value
print("d['key'] =", d['key'])
# d['key'] = 2
try:
    print("d[2] =", d[2]) # Приводит к ошибке
except:
    print('KeyError: 2')
print('--------------------------------------------------------------')



# "Преобразование типов данных"

# Мы можем преобразовывать значения из одного типа в другой с помощью таких функций, 
# как int(), float(), str() и т.д. 
# Для преобразования из/в строку должны использоваться совместимые значения:
print('ПРЕОБРАЗОВАНИЕ ТИПОВ ДАННЫХ ----------------------------------')
print("integer 5 --> float", float(5), type(float(5)))  # 5.0
print("float 10.6 --> integer", int(10.6), type(int(10.6)))  # 10
print("string '2.5' --> float", float('2.5'), type(float('2.5')))  # 2.5
print("integer 25 --> string", str(25), type(str(25)))  # '25'
try:
    int('1p')
except:
    print("ValueError: invalid literal for int() with base 10: '1p'")

# Можно даже преобразовывать одну последовательность в другую:
print("list --> set:", set([1,2,3]), type(set([1,2,3])))  # {1, 2, 3}
print("set --> tuple:", tuple({5,6,7}), type(tuple({5,6,7})))  # (5, 6, 7)
print("string --> list:", list('hello'), type(list('hello')))  # ['h', 'e', 'l', 'l', 'o']

# Для преобразования в словарь каждый элемент последовательности должен быть парой:
print("list --> dictionary:", dict([[1,2],[3,4]]), type(dict([[1,2],[3,4]])))  # {1: 2, 3: 4}
print("list: tuples --> dictionary:", dict([(3,26),(4,44)]), type(dict([(3,26),(4,44)])))  # {3: 26, 4: 44}
print('--------------------------------------------------------------')

